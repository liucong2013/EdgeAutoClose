
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Edge è‡ªåŠ¨å…³é—­ç¨‹åº</title>
    <style>
        /* General Styles */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Microsoft YaHei', Arial, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; display: flex; justify-content: center; align-items: center; color: #333; overflow: hidden; }
        .container { background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px); border-radius: 20px; padding: 30px; box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1); min-width: 400px; text-align: center; }
        .title { font-size: 24px; font-weight: bold; margin-bottom: 20px; color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 10px; }
        .section { margin: 20px 0; padding: 15px; background: rgba(52, 152, 219, 0.1); border-radius: 10px; }
        .section h3 { margin-bottom: 15px; color: #34495e; }
        .time-buttons { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 15px; }
        .time-btn { padding: 12px 20px; border: none; border-radius: 8px; background: linear-gradient(45deg, #3498db, #2980b9); color: white; font-size: 14px; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 2px 10px rgba(52, 152, 219, 0.3); }
        .time-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 20px rgba(52, 152, 219, 0.4); }
        .time-btn:active { transform: translateY(0); }
        .custom-time { display: flex; gap: 10px; align-items: center; justify-content: center; flex-wrap: wrap; }
        .custom-time input { padding: 8px 12px; border: 2px solid #bdc3c7; border-radius: 6px; font-size: 14px; width: 80px; text-align: center; }
        .custom-time input:focus { outline: none; border-color: #3498db; }
        .start-btn { background: linear-gradient(45deg, #27ae60, #2ecc71); color: white; border: none; padding: 15px 30px; border-radius: 10px; font-size: 16px; font-weight: bold; cursor: pointer; margin-top: 20px; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(46, 204, 113, 0.3); }
        .start-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(46, 204, 113, 0.4); }
        .start-btn:disabled { background: #95a5a6; cursor: not-allowed; transform: none; box-shadow: none; }
        .status { margin-top: 20px; padding: 15px; background: #ecf0f1; border-radius: 8px; border-left: 4px solid #3498db; }
        .current-time { font-size: 18px; font-weight: bold; color: #2c3e50; margin-bottom: 10px; }
        .countdown { font-size: 16px; color: #e74c3c; margin-top: 10px; }
        .edge-status { margin-top: 10px; font-weight: bold; }
        .ws-status { margin-top: 10px; font-weight: bold; }
        .info-message { margin-top: 15px; padding: 12px; border-radius: 8px; font-weight: bold; text-align: left; }
        .running { color: #27ae60; }
        .stopped { color: #e74c3c; }
        .warning { background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 6px; padding: 10px; margin: 10px 0; color: #856404; font-size: 12px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="title">ğŸŒ Edge è‡ªåŠ¨å…³é—­ç¨‹åº</div>
        
        <div class="section">
            <h3>â° å¿«é€Ÿè®¾ç½®ï¼ˆå°æ—¶åå…³é—­ï¼‰</h3>
            <div class="time-buttons">
                <button class="time-btn" onclick="setHours(0.5, event)">30åˆ†é’Ÿ</button>
                <button class="time-btn" onclick="setHours(1, event)">1å°æ—¶</button>
                <button class="time-btn" onclick="setHours(2, event)">2å°æ—¶</button>
                <button class="time-btn" onclick="setHours(3, event)">3å°æ—¶</button>
                <button class="time-btn" onclick="setHours(4, event)">4å°æ—¶</button>
                <button class="time-btn" onclick="setHours(6, event)">6å°æ—¶</button>
            </div>
        </div>

        <div class="section">
            <h3>ğŸ¯ ç²¾ç¡®æ—¶é—´è®¾ç½®</h3>
            <div class="custom-time">
                <label>åœ¨</label>
                <input type="number" id="targetHour" min="0" max="23" placeholder="æ—¶">
                <label>:</label>
                <input type="number" id="targetMinute" min="0" max="59" placeholder="åˆ†">
                <label>å…³é—­</label>
            </div>
        </div>

        <div class="section">
            <h3>âš¡ æµ‹è¯•æ¨¡å¼</h3>
            <div class="time-buttons">
                <button class="time-btn" onclick="setSeconds(10, event)">10ç§’å</button>
                <button class="time-btn" onclick="setSeconds(30, event)">30ç§’å</button>
                <button class="time-btn" onclick="setSeconds(60, event)">1åˆ†é’Ÿå</button>
            </div>
        </div>

        <button class="start-btn" id="startBtn" onclick="startMonitoring()">ğŸš€ å¼€å§‹ç›‘æ§</button>
        <button class="start-btn" id="stopBtn" onclick="stopMonitoring()" style="display:none; background: linear-gradient(45deg, #e74c3c, #c0392b);">â¹ï¸ åœæ­¢ç›‘æ§</button>
        <button class="start-btn" id="closeNowBtn" onclick="closeEdgeNow()" style="background: linear-gradient(45deg, #c0392b, #e74c3c); margin-top: 10px;">ğŸš¨ ç«‹å³å…³é—­ Edge</button>

        <div class="status" id="status" style="display: none;">
            <div class="current-time" id="currentTime"></div>
            <div>ç›®æ ‡å…³é—­æ—¶é—´: <span id="targetTime"></span></div>
            <div class="countdown" id="countdown"></div>
            <div class="edge-status" id="edgeStatus">EdgeçŠ¶æ€: æ£€æµ‹ä¸­...</div>
        </div>

        <div class="info-message" id="infoMessage">æ­£åœ¨åˆå§‹åŒ–...</div>

        <div class="warning">
            âš ï¸ ä½¿ç”¨è¯´æ˜ï¼š<br>
            æ­¤ç¨‹åºç°åœ¨é€šè¿‡æœ¬åœ°æœåŠ¡ (edge-stop-server.js) è¿è¡Œã€‚<br>
            1. è¿è¡Œ `deno run --allow-read --allow-run --allow-net edge-stop-server.js` å¯åŠ¨æœåŠ¡ã€‚<br>
            2. åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€ `http://localhost:19100/` è®¿é—®æ­¤ç•Œé¢ã€‚
        </div>
    </div>

    <script>
        let countdownInterval = null;
        let statusInterval = null;
        let targetCloseTime = null;
        let socket = null;
        let config = null; // To store server config

        function updateStatusMessage(message, isError = false) {
            const infoEl = document.getElementById('infoMessage');
            infoEl.textContent = message;
            infoEl.style.color = isError ? '#e74c3c' : '#2c3e50';
            infoEl.style.background = isError ? 'rgba(231, 76, 60, 0.1)' : 'rgba(52, 152, 219, 0.1)';
        }

        // Fetch config from server and then initialize
        async function fetchConfigAndInit() {
            updateStatusMessage('æ­£åœ¨è·å–æœåŠ¡å™¨é…ç½®...');
            try {
                const response = await fetch('http://localhost:19100/config');
                if (!response.ok) throw new Error('Could not fetch config');
                config = await response.json();
                updateStatusMessage('âœ… æœåŠ¡å™¨é…ç½®å·²åŠ è½½ï¼Œæ­£åœ¨è¿æ¥ WebSocket...');
                setupWebSocket(); // Now setup WebSocket with the correct URL
            } catch (error) {
                console.error('Failed to fetch config:', error);
                updateStatusMessage('âŒ æ— æ³•åŠ è½½æœåŠ¡å™¨é…ç½®ï¼Œè¯·ç¡®ä¿æœåŠ¡æ­£åœ¨è¿è¡Œã€‚', true);
            }
        }

        function highlightButton(event, color) {
            document.querySelectorAll('.time-btn').forEach(btn => {
                btn.style.background = 'linear-gradient(45deg, #3498db, #2980b9)';
            });
            if (event) event.target.style.background = color;
        }

        function setHours(hours, event) {
            highlightButton(event, 'linear-gradient(45deg, #e74c3c, #c0392b)');
            const target = new Date(new Date().getTime() + hours * 60 * 60 * 1000);
            document.getElementById('targetHour').value = target.getHours();
            document.getElementById('targetMinute').value = target.getMinutes();
        }

        function setSeconds(seconds, event) {
            highlightButton(event, 'linear-gradient(45deg, #f39c12, #e67e22)');
            const target = new Date(new Date().getTime() + seconds * 1000);
            document.getElementById('targetHour').value = target.getHours();
            document.getElementById('targetMinute').value = target.getMinutes();
        }

        async function startMonitoring() {
            let hour = parseInt(document.getElementById('targetHour').value);
            let minute = parseInt(document.getElementById('targetMinute').value);

            if (isNaN(hour) || isNaN(minute) || hour < 0 || hour > 23 || minute < 0 || minute > 59) {
                updateStatusMessage('è¯·è¾“å…¥æœ‰æ•ˆçš„æ—¶é—´ï¼', true);
                return;
            }

            const now = new Date();
            let initialTargetTime = new Date();
            initialTargetTime.setHours(hour, minute, 0, 0);

            if (initialTargetTime <= now) {
                initialTargetTime.setDate(initialTargetTime.getDate() + 1);
            }

            targetCloseTime = new Date(initialTargetTime.getTime() + 2 * 60 * 1000);
            updateStatusMessage('å·²å¢åŠ 2åˆ†é’Ÿç¼“å†²ä»¥é¢„ç•™å…³é—­æ—¶é—´ã€‚');

            try {
                const response = await fetch('http://localhost:19100/close-edge', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ hour: initialTargetTime.getHours(), minute: initialTargetTime.getMinutes() })
                });
                if (!response.ok) throw new Error(await response.text());
                updateStatusMessage('âœ… å…³é—­è¯·æ±‚å·²å‘é€ï¼');
                enterMonitoringState(targetCloseTime);
            } catch (error) {
                updateStatusMessage(`âŒ å‘é€å…³é—­è¯·æ±‚å¤±è´¥: ${error.message}`, true);
            }
        }

        function stopMonitoring() {
            clearInterval(countdownInterval);
            clearInterval(statusInterval);
            countdownInterval = null;
            statusInterval = null;
            targetCloseTime = null;

            document.getElementById('status').style.display = 'none';
            document.getElementById('startBtn').style.display = 'inline-block';
            document.getElementById('stopBtn').style.display = 'none';
            highlightButton(null, null);
            updateStatusMessage('ç›‘æ§å·²åœ¨ç•Œé¢ä¸Šåœæ­¢ã€‚');
        }

        let remoteCloseTimer = null;

        function startRemoteCloseCountdown() {
            if (remoteCloseTimer) clearInterval(remoteCloseTimer);

            let seconds = 5;
            updateStatusMessage(`æ”¶åˆ°æœåŠ¡å™¨å…³é—­æŒ‡ä»¤ï¼å°†åœ¨ ${seconds} ç§’åå…³é—­ Edge...`, true);

            remoteCloseTimer = setInterval(() => {
                seconds--;
                if (seconds > 0) {
                    updateStatusMessage(`å°†åœ¨ ${seconds} ç§’åå…³é—­ Edge...`, true);
                } else {
                    clearInterval(remoteCloseTimer);
                    closeEdgeNow(true);
                }
            }, 1000);
        }

        async function closeEdgeNow(skipConfirmation = false) {
            const confirmed = skipConfirmation || confirm("æ‚¨ç¡®å®šè¦ç«‹å³å…³é—­æ‰€æœ‰ Edge æµè§ˆå™¨çª—å£å—ï¼Ÿæ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚");
            if (confirmed) {
                updateStatusMessage('æ­£åœ¨å‘é€ç«‹å³å…³é—­æŒ‡ä»¤...');
                try {
                    const response = await fetch('http://localhost:19100/close-edge-now', { method: 'POST' });
                    const result = await response.json();
                    if (response.ok) {
                        updateStatusMessage(`âœ… ${result.message}`);
                    } else {
                        throw new Error(result.message);
                    }
                } catch (error) {
                    updateStatusMessage(`âŒ æŒ‡ä»¤å‘é€å¤±è´¥: ${error.message}`, true);
                }
            }
        }

        function enterMonitoringState(targetTime) {
            targetCloseTime = targetTime;
            document.getElementById('status').style.display = 'block';
            document.getElementById('targetTime').textContent = targetTime.toLocaleTimeString('zh-CN', { hour12: false, hour: '2-digit', minute: '2-digit' });
            document.getElementById('startBtn').style.display = 'none';
            document.getElementById('stopBtn').style.display = 'inline-block';

            if (countdownInterval) clearInterval(countdownInterval);
            countdownInterval = setInterval(updateCountdown, 1000);
            updateCountdown();

            if (statusInterval) clearInterval(statusInterval);
            statusInterval = setInterval(updateEdgeStatus, 5000);
            updateEdgeStatus();
        }

        async function updateCountdown() {
            if (!targetCloseTime) return;
            const diff = targetCloseTime - new Date();
            if (diff <= 0) {
                document.getElementById('countdown').textContent = 'æ—¶é—´åˆ°ï¼æ­£åœ¨å…³é—­æœåŠ¡å™¨...';
                clearInterval(countdownInterval);
                clearInterval(statusInterval);
                try {
                    await fetch('http://localhost:19100/shutdown', { method: 'POST' });
                    showNotification('æœåŠ¡å™¨å·²å…³é—­ã€‚');
                    document.getElementById('edgeStatus').textContent = 'ä»»åŠ¡å®Œæˆï¼ŒæœåŠ¡å™¨å·²å…³é—­ã€‚è¯·æ‰‹åŠ¨å…³é—­æ­¤é¡µé¢ã€‚';
                    document.getElementById('edgeStatus').className = 'edge-status stopped';
                    document.getElementById('stopBtn').disabled = true;
                } catch (e) {
                    showNotification('æœåŠ¡å™¨å…³é—­å¤±è´¥ï¼Œå¯èƒ½å·²ç¦»çº¿ã€‚', true);
                    document.getElementById('edgeStatus').textContent = 'æœåŠ¡å™¨æ— å“åº”ï¼Œè¯·æ‰‹åŠ¨å…³é—­ã€‚';
                }
                return;
            }
            const h = Math.floor(diff / 3600000).toString().padStart(2, '0');
            const m = Math.floor((diff % 3600000) / 60000).toString().padStart(2, '0');
            const s = Math.floor((diff % 60000) / 1000).toString().padStart(2, '0');
            document.getElementById('countdown').textContent = `å€’è®¡æ—¶: ${h}:${m}:${s}`;
        }

        async function updateEdgeStatus() {
            try {
                const response = await fetch('http://localhost:19100/status');
                const data = await response.json();
                const statusEl = document.getElementById('edgeStatus');
                if (data.isRunning) {
                    statusEl.textContent = 'BATçŠ¶æ€: æ­£åœ¨è¿è¡Œ';
                    statusEl.className = 'edge-status running';
                } else {
                    statusEl.textContent = 'BATçŠ¶æ€: æœªè¿è¡Œ';
                    statusEl.className = 'edge-status stopped';
                }
            } catch (error) {
                console.error("Could not get status:", error);
                const statusEl = document.getElementById('edgeStatus');
                statusEl.textContent = 'BATçŠ¶æ€: æœªçŸ¥ (æœåŠ¡å™¨æ— å“åº”)';
                statusEl.className = 'edge-status stopped';
            }
        }

        function setupWebSocket() {
            if (!config || !config.websocketUrl) {
                console.error('WebSocket URL not found in config.');
                return;
            }
            const wsStatus = document.getElementById('wsStatus');
            const url = config.websocketUrl; // Use URL from config
            socket = new WebSocket(url);

            socket.onopen = () => {
                updateStatusMessage('âœ… WebSocket å·²æˆåŠŸè¿æ¥');
            };

            socket.onmessage = (event) => {
                console.log('WebSocket message:', event.data);

                if (event.data === 'stop edge') {
                    startRemoteCloseCountdown();
                    return;
                }

                // Handle other messages, assuming they are JSON for status updates
                try {
                    const msg = JSON.parse(event.data);
                    if (msg.type === 'status') {
                        const statusEl = document.getElementById('edgeStatus');
                        if (msg.isRunning) {
                            statusEl.textContent = 'BATçŠ¶æ€: æ­£åœ¨è¿è¡Œ';
                            statusEl.className = 'edge-status running';
                        } else {
                            statusEl.textContent = 'BATçŠ¶æ€: æœªè¿è¡Œ';
                            statusEl.className = 'edge-status stopped';
                        }
                    }
                } catch (e) {
                    // If it's not a 'stop edge' command and not a valid JSON, just log it.
                    console.log('Received non-JSON message:', event.data);
                    updateStatusMessage(`æ”¶åˆ°æœªçŸ¥æ¶ˆæ¯: ${event.data}`);
                }
            };

            socket.onclose = () => {
                updateStatusMessage('ğŸ”Œ WebSocket å·²æ–­å¼€ï¼Œæ­£åœ¨å°è¯•é‡æ–°è¿æ¥...', true);
                setTimeout(setupWebSocket, 5000); // Try to reconnect every 5 seconds
            };

            socket.onerror = (error) => {
                updateStatusMessage('âŒ WebSocket è¿æ¥å‘ç”Ÿé”™è¯¯', true);
                console.error('WebSocket error:', error);
            };
        }

        // Initial setup
        document.addEventListener('DOMContentLoaded', () => {
            fetchConfigAndInit();
            setInterval(() => document.getElementById('currentTime').textContent = `å½“å‰æ—¶é—´: ${new Date().toLocaleTimeString('zh-CN')}`, 1000);
            updateEdgeStatus();
        });
    </script>
</body>
</html>
